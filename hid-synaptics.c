/*
 *  HID driver for synaptics devices
 *
 *  Copyright (c) 2014 Simon WÃ¶rner
 */

/*
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 */

#include <linux/device.h>
#include <linux/hid.h>
#include <linux/module.h>
#include <linux/usb.h>

#define DEBUG_SYNAPTICS

static __u8 synaptics_kbd_rdesc_fixed[] = {
	0x06, 0x85, 0xff, 0x09, 0x95, 0xa1, 0x01, 0x85, 0x5a, 0x09, 0x01, 0x15, 0x00, 0x26, 0xff, 0x00, 0x75, 0x08, 0x95, 0x10, 0xb1, 0x00, 0xc0

	0x05, 0x01, 0x09, 0x06, 0xa1, 0x01, 0x85, 0x01, 0x75, 0x01, 0x95, 0x08, 0x05, 0x07, 0x19, 0xe0, 0x29, 0xe7, 0x15, 0x00, 0x25, 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x08, 0x81, 0x03, 0x95, 0x05, 0x75, 0x01, 0x05, 0x08, 0x19, 0x01, 0x29, 0x05, 0x91, 0x02, 0x95, 0x01, 0x75, 0x03, 0x91, 0x03, 0x95, 0x06, 0x75, 0x08, 0x15, 0x00, 0x26, 0xff, 0x00, 0x05, 0x07, 0x19, 0x00, 0x2a, 0xff, 0x00, 0x81, 0x00, 0xc0

	0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 0x85, 0x02, 0x19, 0x00, 0x2a, 0x3c, 0x02, 0x15, 0x00, 0x26, 0x3c, 0x02, 0x75, 0x10, 0x95, 0x01, 0x81, 0x00, 0xc0

	0x05, 0x01, 0x09, 0x0c, 0xa1, 0x01, 0x85, 0x03, 0x15, 0x00, 0x25, 0x01, 0x09, 0xc6, 0x95, 0x01, 0x75, 0x01, 0x81, 0x06, 0x75, 0x07, 0x81, 0x03, 0xc0

	// orginal
	//0x05, 0x88, 0x09, 0x01, 0xa1, 0x01, 0x85, 0x04, 0x19, 0x00, 0x2a, 0xff, 0xff, 0x15, 0x00, 0x26, 0xff, 0xff, 0x75, 0x08, 0x95, 0x02, 0x81, 0x02, 0xc0

	// fixed
	0x05, 0x88, 0x09, 0x01, 0xa1, 0x01, 0x85, 0x04, 0x19, 0x00, 0x2a, 0xff, 0x2f, 0x15, 0x00, 0x26, 0xff, 0x2f, 0x75, 0x08, 0x95, 0x02, 0x81, 0x02, 0xc0

	0x05, 0x01, 0x09, 0x80, 0xa1, 0x01, 0x85, 0x05, 0x19, 0x81, 0x29, 0x83, 0x15, 0x00, 0x25, 0x01, 0x95, 0x08, 0x75, 0x01, 0x81, 0x02, 0xc0
};

/*
static int synaptics_raw_event(struct hid_device *hdev, struct hid_report *report,
		__u8 *rawdata, int size)
{
	// nothing done so far

    return 0;
}
*/

static __u8 *synaptics_kbd_report_fixup(struct hid_device *hdev, __u8 *rdesc,
unsigned int *rsize)
{
	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);

	if (intf->cur_altsetting->desc.bInterfaceNumber == 0) {
		rdesc = synaptics_kbd_rdesc_fixed;
		*rsize = sizeof(synaptics_kbd_rdesc_fixed);
	}
	return rdesc;
}

static int synaptics_probe(struct hid_device *hdev, const struct hid_device_id *id)
{
	int ret;

#ifdef DEBUG_SYNAPTICS
	printk(KERN_ALERT "synaptics_probe\n");
#endif

	hdev->quirks |= id->driver_data;

	ret = hid_parse(hdev);
	if (ret) {
		hid_err(hdev, "parse failed\n");
		goto err_free;
	}

	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
	if (ret) {
		hid_err(hdev, "hw start failed\n");
		goto err_free;
	}

	if (ret < 0)
		goto err_stop;

	return 0;
err_stop:
	hid_hw_stop(hdev);
err_free:
	return ret;
}

static void synaptics_remove(struct hid_device *hdev)
{
	hid_hw_stop(hdev);
	kfree(hid_get_drvdata(hdev));
}

#define USB_VENDOR_ID_SYNAPTICS         		0x06cb
#define USB_VENDOR_ID_SYNAPTICS_KEYBOARD		0x2968

static const struct hid_device_id synaptics_devices[] = {
	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_VENDOR_ID_SYNAPTICS_KEYBOARD) },
	{ }
};
MODULE_DEVICE_TABLE(hid, synaptics_devices);

static struct hid_driver synaptics_driver = {
	.name = "synaptics",
	.id_table = synaptics_devices,
	.report_fixup = synaptics_kbd_report_fixup,
	.probe = synaptics_probe,
	.remove = synaptics_remove,
	//.raw_event = synaptics_raw_event
};

static int __init synaptics_init(void)
{
#ifdef DEBUG_SYNAPTICS
	printk(KERN_ALERT "synaptics_init\n");
#endif
	return hid_register_driver(&synaptics_driver);
}

static void __exit synaptics_exit(void)
{
#ifdef DEBUG_SYNAPTICS
	printk(KERN_ALERT "synaptics_exit\n");
#endif
	hid_unregister_driver(&synaptics_driver);
}

module_init(synaptics_init);
module_exit(synaptics_exit);
MODULE_LICENSE("GPL");
